/*
    프로그램(Program) 
    : 프로그래머가 만든 프로그램 실행 파일
    프로세스(Process) 
    : CPU가 실행파일의 명령들을 읽어서 메모리에 재구성한 것. 
    : 실행 중인 프로그램 이라고도 함
    -> 세그먼트의 집합으로 구성된다.
    
    세그먼트(segment)
    : 정보 및 사용자가 입력한 데이터를 기억하는 메모리 공간
    세그먼트의 종류
    1.  Code Segment 
    -> 실행 파일이 실행시 프로세스가 만들어진 코드를 저장
    -> 기계어 명령문
    2.  Data Segment 
    -> 프로그램이 종료될 때까지 사용되는 데이터를 보관되는 곳
    -> 전역변수, static전역변수, 문자열 상수 목록
    3, Stack Segment 
    -> 프로그램 실행 중 임시데이터를 저정하는 메모리 영역
    -> 동적메모리할당(Heap), 지역변수(Stack)

    메모리 할당
    : 데이터를 저장할 공간을 적정하게 나누는 작업
    : 프로그램이 운영체제에서 배정 받은 메모리 공간

    정적메모리 할당(Static Memory Allocation)
    : 변수에 크기에 맞게 메모리를 할당하는 것
    : 프로그램 실행 시 메모리의 위치가 결정됨.
    : 프로그램 실행 중 할당된 메모리 크기는 변경 불가!!

    변수가 메모리에서 유리되는 시간
    1. 전역변수 : 프로그램 종료시까지, 변수 추가.삭제 불가, data Segment에 저장됨
    2. 지역변수 : 함수 호출 시 함수가 끝나면 사라짐, Stack Segment에 저장됨
*/

/*
    16-2 지역변수와 스택

    1. 스택에 대해서
    : 베이스 포인터(Base Pointer, BP)기준으로 데이터가 추가될 때마다 순서대로 쌓아 올리는 구조
    : 새로운 데이터가 추가될 위치를 스택 포인터(Stack Pointer, SP)
    : Start포인터, 스택 포인터가 END포인터가 되겠지여
    PUSH : 베이스 포인터의 4바이트씩 데이터 추가하는 작업
    POP : 스텍포인터로 부터 -4바이트씩 데이터 값을 삭제하는 작업

    컴퓨터 시스탬(실제)
    PUSH : 스택 포인터 주소 감소(-) , POP : 스택 포인터 주소 증가(+)
    mov ax, 4  - push ax - pop ax
    
    2. 컴파일러가 지역 변수를 저장할 메모리 공간을 확보하는 방법
    void Test(){int a, b, c;}
    push ax - push ax - push ax ... pop ax - pop ax - pop ax

    3. sub add 명령을 사용하는 방법
    void Test(){int a, b, c;} -- sub SP,12 - add SP, 12

    4. 컴파일러가 스택에 할당된 지역 변수를 사용하는 원리
    void Test(){int a, b, c;}
    - 블록 c를 꺼내고 bx레지스터에 저장
    - 블록 b를 꺼내고 bx레지스터에 저장하고 값을 5로 변경
    - 스택에 다시 pushgkrh, pop했던 블록 ㅊ 값을 다시 스택에 push함.

    블록과 레지스터의 차이점
    블록 -> 다량의 변수를 저장되는 공간
    레지스터 -> CPU에서 연산을 수행할 때 사용되는 메모리
    // 스택 포인터를 사용해 스택에 할당된 지역 변수를 사용가능 - push수행시 SP+8이 SP+4처럼 동작한다. 
    
    5. 함수를 호출할 때 스택 메모리가 변화하는 과정
    - main함수가 Test함수 호출하기
    인스트럭션 포인터(Instruction Pointer, IP) 레지스터 값을 스택에 저장하는 것
    베이스 포인터와 스택 포인터에 저장된 주소를 Test함수 기준으로 변강한다.
    // IP 레지스터와 main함수가 사용하던 베이스 포인터 위치를 스택에 push하여 보관했다.
    - Test함수가 Show 함수 호출하기
    - Show 함수 종료하기

    6. 스택 프레임(Stack Frame)이란?
    : 함수를 호출할 때 일어나는 스택의 변화
    : 변수를 저장할 메모리 위치를 배정하는 것을 '정적 메모리 할당'이라 한다.
*/

/*
    16-3 동적 메모리 할당 및 해제

    정적 메모리 할당의 한계
    : 프로그램이 사용할 전체 스택의 크기는 단순히 각 함수에 선언한 지역 변수
      의 크기를 합산해서 예측할 수는 없습니다.
    : 스택을 사용하는 크기가 1byte를 넘게 되면 메모리의 Stack overflow(실행오류)발생

    동적 메모리 할당이란?
    : 프로세스는 더 큰 메모리를 할당하여 사용할 수 있도록 Heap이란 공간 제공
    : 스택 프레임 규칙을 통해 코드가 컴파일될 때 사용할 메모리 크기를 결정합니다.
    : 메모리 사용이 끝나면 할당한 메모리 공간을 해체할 수 있는ㅊ 것을 의미.
    
    malloc[memory allocation] 함수로 동적 메모리 할당하기
    : 힙은 스택처럼 관리되는 공간이 아니라서 malloc을 사용해서 메모리를 할당해야 한다.
    : 동적으로 메모리를 할당할때 그룹으로 묶어 사용할 수 있음.

    free 함수로 할당된 메모리 해제하기
    : 스택에 할당한 지역변수는 스택 프레임에 의해 자동으로 해제된다.
    : 힙에 할당한 메모리는 플로그램이 끝날 때 가지 자동으로 해제되지 않는다.
    : free 함수를 사용하여 힙에 할당했던 메모리를 명시적으로 해제해주어야 합니다.

    malloc 함수를 사용할 때 주의할 점
    메모리 손실
    -> 메모리의 주소값을 알 수 있는 방법이 없어서 해당 메모리를 사용할 수 없고 
       해제할 수도 없는 상태
    
    동적 메모리 할당의 장단점

*/

/*
    16-4 동적 메모리 사용하기

    배열과 비슷한 형식으로 동적 메모리 사용하기
    : 작은 데이터를 여러 개를 동적으로 할당해서 사용하는 것은 번거로워
      메모리를 배열처럼 그룹으로 붂어서 많이 사용합니다.

    정적 메모리 할당을 사용했을 때 발생할 수 있는 문제점
    : 뱌열의 크기를 상수로만 받아서 생기는 것
    // 사용자가 입력햔 숫자의 개수를 제한할 수 밖에 없어 - 최대 입력을 받도록 구성
    -> 사용자마다 요청할 때 마다 변결해서 다시 컴파일하며 재배포하면
       프로그램의 유지보수에 엄청난 부담을 줄 수 있습니다.
    // 뱌열을 사용하는 프로그램은 제한적 사용 및 메모리를 맘ㄶ이 낭비할 수 밖에 없다.

    malloc 함수는 메모리 할당 크기를 변수로 지정할 수 있다.
    : 배열 문법이 하용하기 편하지만 제약 사항이 많다.
    /// 사용자가 숫자의 개수르 지정할 수 있기 때문에 코드를 수정할 필요가 없습니다.
*/