/*
    데이터 저장 단위
    비트(bit) : 2가지 중 한가지 값을 저장할 수 있는 단위
    바이트(Bybe) : 8개의 비트로 구성된 저장단위
    ASCII : 컴퓨터에서 문자를 숫자로 표현하기 위한 약속

    자료형(Data Type) : 실제로 메모리를 사용하는 단위
    Built-in data Type -> 사용 빈도가 높은 자료형을 예약어로 제공
    User-defined data Type -> 사용자가 만들어서 사용할 수 있는 문법 제공 
                           -> 사용자 정의 데이터 타입
    부호가 있는 경우 : signed
    부호가 없는 경우 : unsugned

    상수 : 숫자형(정수형-실수형), 문자형, 문자열형 -> 개행문자를 포함시 -1을 해야함.

    라이브러리 : 변경가능성이 없는 파일들은다른 곳에 보관하구
               몸ㄱ적 파일을 소스 목록에 포함시켜 박업하여 효율성을 높인다.
    ex> main.c 소스파일 -> MyMath.h 헤더 파일 , MyMath.lib 라이브버리 파일
    전처리기 -> 프로그래머가 원하는 사랑을 컴파일러에게 직접 지시하는 문법
    #define -> 상수나 명령문을 치환하는 문법
    Macro function -> #define POW_VALUE(a) (a * a)

    구문 오류(Syntx Error) -> 규칙을 제대로 지키지 않았을 대 발생
    의미상 오류(Semantic Error) 
    -> 문법적으로는 맞지만, 의미적으로 틀리 때 발생 , 디버깅(debugging):버그를 해결하기 위해 작업하는 행위

    goto 제어문
    -> 자신이 지정한 레이블(Lable)위치로 바로 이동
    -> C 언어의 구조화된 문법을 파괴함.

    extern 키워드
    -> 연관이 깊은 함수끼리 묶어 파일을 나누어 관리하면 변경된 부분만 다시 컴파일로 편리
    -> 소스코드 분리시 동일한 전역변수의 경우 한쪽에서 전역 변수를 참조하지 못하는 오류 발생
    해당 프로젝트의 소스파일의 경우 전역변수가 같을때, exerm 키워트 사용시 정상적으로 extern 참조
    단, extern참조에서 초기화를 사용할 시 일반전역변수로 처리되어 사용이 가능, 단 변수이름은 달라야함.

    const키워드 
    -> 변수의 값을 변경하는 경우 문법적으로 오류가 발생하도로 제공하는 문법
    -> 프로그래머의 실수 방지를 위해 제공하는 문법

    array은 사용자 정의 자료형(User-defined Data type)
    -> 같은 크기의 메모리를 그룹으로 묶어 새로운크기의 변수를 만듬.
    -> 문자열 상수를 통한 배열만들의 편의 길이 구하기(EOL, End Of Line)
    while(data[count]!=0){count++;} //널 문자까지 count 증가..

    문자열을 다루는 C내장 함수
    -> #include <string.h> strlen = string + length , strcpy = string + copy
                           strcat = string + concatenation 문자열을 덧붙이는 문자열 표준 함수
*/

/*
    운영체제의 메모리 관리 방식_운영체제와 프로그래밍
    -> 변수 - 컴파일 -> 메모리 주소
    -> 32비트 프로그래밍 int형이 4바이트 , 64비트 프로그래밍은 주소를 저장하거나 사용할 때 4바이트로 표현

    운영체제의 메모리 관리 방식_메모리 주소 지정 방식
    -> 운영체제는 메모리 주소를 1바이드 단위로 관리
    -> 메모리 사용시 만드시를 주소 및 한 법에 읽거나 저장할 크기를 명시해야만 한다.

    운영체제의 메모리 관리 방식_직접 주소 지정 방식
    -> 메모리를 사용할 대 프로그래머가 사용할 메모리 주소를 직접 적는 방식
    -> c언어의 '변수'문법과 같음 ex> short birthday; birthday = 0x0412 mov word ptr[0x00000066h]
    // 메모리 주소 대신 변수 이름을 사용하면 코드를 더 쉽게 이해 가능 
       단, 문법 구조상 다른 함수에 존재하는 변수 참조 불가능

    정리 :
    직접 주소 지정 방식은 주소를 직접 명시한다.
    간접 주소 지정 방식은 사물함이라는 매개체를 이용해 주소르 간접적으로 명시한다.
*/

/*
    포인터
    -> 일반 변수도 주소를 저장할 수 이디만, 저장된 부소의 메모리에 가서 값을 읽거나 저장할 수 없다.
    -> 포인터 변수는 자료형을 선언하지 않아도 무조건 크기가 4바이트
    -> c언어는 간접 주소 지적 방식으로 동작하는 문법을 제공한다. short *ptr
    -> 보다 더 안전한 포인터 사용은 직접입력 보단 "다른 변수의 부소를 받아와 사용하는 것이 안전"
    ex> short birthday; short *ptr; tor = &birthday

     ptr = -> 포인터 변수의 값이 변경되는 것   , short *ptr; ptr = (short*)0x000006C
    *ptr = -> 포인터가 가리키는 대상의 값이 변경, *ptr = 0x0412
    -> 모든 변수가 같은 함수에 선언되는 것은 아니기 때문.
    -> 일반 변수는 다른 함수에 있는 변수 사용불가 단 포인터 변수는 변수의 값을 읽거나 변경 가능

    포인터와 const키워em -> p가 가지고 잇는 주소를 변경하면 번역할 때 오류 발생
    -> ex> int data = 5, temp = 0; int * const p = &data;
           *p = 3; p = &temp; // p에 저장된 주소 변경 불가
    -> ex> int data = 5; const int*p = &data; *p = 3; 
           // 변수 p가 가리키는 대상의 값 변경 불가!
    -> ex> int data = 5, temp = 0; const int * const p = &data; 
           *p = 3; p = &temp; // p가 가리키는 값과 주소를 변경할 수 없음.
*/

#include <stdio.h>

void Test (short *ptr){
    short soft = 0;
    soft = *ptr;
    *ptr = 3;
}

void Swap(int *pa, int*pb){
    int temp = *pa;
    *pa = *pb;
    *pb = temp;
}

int main(){
    short tips = 5;
    Test(&tips);

    int start = 96, end = 5;
    if(start > end){Swap(&start, &end);}
    printf("after : start = %d, end = %d\n", start, end);
    return 0;
}

/*
    포인터 변수의 주소 연산_사용할 메모리의 범위를 기억하는 방법
    1. 시작 주소와 긑 주소를 기억하는 것
    2. 시작 주소와 사용할 크기를 기억하는 것
    
    포인터 변수의 부소 연산_시작 주소와 끝 주소로 메모리 범위 기억하기
    -> 총 8바이트가 필요함.

    int *p; -> 대상의 크기와 시작 주소 기억
    -> 메모리 크기는 명령문에 포함되어 있어 자신이 사용할 메모리의 시작 주소만 기억하면 됨.
*/




